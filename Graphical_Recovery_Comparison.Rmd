# Goal - Generation of graphical model p values, adjustment using 
              a) Two step BY adjustment
              b) Global BY adjustment
          subsequently, generate accuracy for graph recovery for method comparison

```{r}
### Prelim function loading
require(tidyverse)
source('variance_functions_SSR_v5.R')
closeAllConnections()

```


```{r}
Test_tibble_global = Test_tibble |>
  ungroup() |>
  mutate(
    # Create a combined vector of all Re and Im p-values for global adjustment
    test_id = row_number()
  )

# Getting all p-values in one vector
all_pvals = c(Test_tibble_global$Re, Test_tibble_global$Im)
all_pvals_adjusted = p.adjust(all_pvals, method = "BY")
```

```{r}
library(dplyr)

Test_tibble_global = Test_tibble |>
  group_by(i) |>
  group_modify(\(df, key) {
    all_pvals = c(df$Re, df$Im)
    all_adj = p.adjust(all_pvals, method = "BY")
    n_tests = nrow(df)
    df$Re_global_BY = all_adj[1:n_tests]
    df$Im_global_BY = all_adj[(n_tests + 1):(2 * n_tests)]
    df$global_BY_min = pmin(df$Re_global_BY, df$Im_global_BY)
    df
  }) |>
  ungroup()


```

```{r}

# Step 1: Within each (a, c, r, k, i) group, adjust Re and Im p-values jointly
Test_tibble_twostep = Test_tibble |>
  group_by(a, c, r, k, i) |>
  group_modify(\(df, key) {
    all_pvals = c(df$Re, df$Im)
    all_adj = p.adjust(all_pvals, method = "BY")
    n_tests = nrow(df)
    df$Re_step1_BY = all_adj[1:n_tests]
    df$Im_step1_BY = all_adj[(n_tests + 1):(2 * n_tests)]
    df$step1_min = pmin(df$Re_step1_BY, df$Im_step1_BY)
    df
  }) |>
  ungroup()

# Step 2: Apply BY correction across all step1_min values
Test_tibble_twostep = Test_tibble_twostep |>
  mutate(twostep_BY = p.adjust(step1_min, method = "BY"))

# Step 3: Merge with global BY results for comparison
Test_tibble_final = Test_tibble |>
  left_join(
    Test_tibble_global |> select(a, c, r, k, i, global_BY_min),
    by = c("a", "c", "r", "k", "i")
  ) |>
  left_join(
    Test_tibble_twostep |> select(a, c, r, k, i, twostep_BY),
    by = c("a", "c", "r", "k", "i")
  )

```

```{r}
### Truth of the graphical model
### (1,2) (2,3) connections , (1,1) time varying

graph_recovery = Test_tibble_final |>
  group_by(i) |>
  summarise(
    # For Global BY method
    # Check if each true edge is detected (min p-value < alpha for any r)
    global_detect_12 = any(a == 1 & c == 2 & global_BY_min < alpha) |
                       any(a == 2 & c == 1 & global_BY_min < alpha) ,
    global_detect_23 = any(a == 2 & c == 3 & global_BY_min < alpha) | 
                       any(a == 3 & c == 2 & global_BY_min < alpha),
    global_detect_11_tv = any(a == 1 & c == 1 & r > 0 & global_BY_min < alpha),
    
    # Count number of significant edges (excluding diagonal)
    global_n_edges = nrow(distinct(data.frame(
          a2 = pmin(a[a != c & global_BY_min < alpha],
                c[a != c & global_BY_min < alpha]),
          c2 = pmax(a[a != c & global_BY_min < alpha],
                c[a != c & global_BY_min < alpha])
          )
        )
      )
,
    
    # For Two-Step BY method  
    twostep_detect_12 = any(a == 1 & c == 2 & twostep_BY < alpha) |
                        any(a == 2 & c == 1 & global_BY_min < alpha),
    twostep_detect_23 = any(a == 2 & c == 3 & twostep_BY < alpha) |
                        any(a == 3 & c == 2 & twostep_BY < alpha),
    twostep_detect_11_tv = any(a == 1 & c == 1 & r > 0 & twostep_BY < alpha),
    
    # Count number of significant edges for two-step
    twostep_n_edges = nrow(distinct(data.frame(
          a2 = pmin(a[a != c & twostep_BY < alpha],
                c[a != c & twostep_BY < alpha]),
          c2 = pmax(a[a != c & twostep_BY < alpha],
                c[a != c & twostep_BY < alpha])
          )
        )
      ),
    
    .groups = "drop"
  )
```

```{r}
### Define true edge set here
true_edges_set = c("(1,2)", "(2,1)" , "(2,3)", "(3,2)")  # Adjust based on your actual model
true_edges_including_diag = c("(1,2)", "(2,1)" , "(2,3)", "(3,2)", "(1,1)")

accuracy_summary = graph_recovery |>
  mutate(
    # Global BY: Perfect recovery if all true edges detected and no false positives
    global_all_true_detected = global_detect_12 & global_detect_23 & global_detect_11_tv,
    
    # Check if ONLY the true edges are detected (perfect graph)
    # In TVVAR3 case We expect 2 off-diagonal true edges: some combo of (1,2) and (3,2)
    global_perfect = global_all_true_detected & (global_n_edges == 2),
    
    # Two-Step BY: Perfect recovery
    twostep_all_true_detected = twostep_detect_12 & twostep_detect_23 & twostep_detect_11_tv,
    
    twostep_perfect = twostep_all_true_detected & (twostep_n_edges == 2),
    
    # Partial credit metrics
    global_sensitivity = (global_detect_12 + global_detect_23 + global_detect_11_tv) / 3,
    twostep_sensitivity = (twostep_detect_12 + twostep_detect_23 + twostep_detect_11_tv) / 3
  )
```

```{r}
overall_accuracy = tibble(
  Method = c("Global BY", "Two-Step BY"),
  
  # Perfect graph recovery rate
  Perfect_Recovery = c(
    mean(accuracy_summary$global_perfect),
    mean(accuracy_summary$twostep_perfect)
  ),
  
  # All true edges detected (but can still have false positives)
  All_True_Detected = c(
    mean(accuracy_summary$global_all_true_detected),
    mean(accuracy_summary$twostep_all_true_detected)
  ),
  
  # edge detection rates by pair
  Detect_12 = c(
    mean(accuracy_summary$global_detect_12),
    mean(accuracy_summary$twostep_detect_12)
  ),
  
  Detect_23 = c(
    mean(accuracy_summary$global_detect_23),
    mean(accuracy_summary$twostep_detect_23)
  ),
  
  Detect_11_TV = c(
    mean(accuracy_summary$global_detect_11_tv),
    mean(accuracy_summary$twostep_detect_11_tv)
  ),
  # Sensitivity (proportion of true edges detected)
  Mean_Sensitivity = c(
    mean(accuracy_summary$global_sensitivity),
    mean(accuracy_summary$twostep_sensitivity)
  ),
  
  # Mean number of detected edges
  Mean_N_Edges = c(
    mean(accuracy_summary$global_n_edges),
    mean(accuracy_summary$twostep_n_edges)
  ),
  
  # False positive rate (extra edges attributed)
  Mean_False_Positives = c(
    mean(pmax(0, accuracy_summary$global_n_edges - 2)),
    mean(pmax(0, accuracy_summary$twostep_n_edges - 2))
  )
)

```

